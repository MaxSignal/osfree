
Notes about LX loader

8 oct 2007

Sources
Some parts in how to handling fixups are inspired from kLdr. And the rest is mostly
based on the specification for LX. A link about linkers and loders: 
  www.iecc.com/linker/linker08.html
How to create a really small LX exe.
Fandango on core: http://lafaix.online.fr/os2/contest.html
OS/2 Miniaturization Contest: http://pages.prodigy.net/michaln/os2/os2mini.html
-----------------------------------------------------------------------------------

What it can do. Limited loading of LX exe and dll files. Some support of elf shared 
libraries to connect it to the underlying system (in the file "native_dynlink.c").

This code has been constructed as a library, with a driver program in "test_os2start.cc".

A desription of the driver program follows, where it initializes the different parts. 
Such as:
	The module list, in "dynlink.c". A list of loaded dlls and the loaded exe module. 
	Don't know if this is the "right" behavior to do.
	
	Libpath and native libpath. The search path for dlls and for "native" ELF libraries.

After that the exe file is opened and the LX header is read with one of two different 
methods. One way is when the exe is from a memory buffer with "load_lx_stream()" which 
is a kind of a constructor for the structure "LX_module" and the other method with a
file "load_lx()". These two constructors sets up two function pointers inside the structure.
This way LX loader can read from both a buffer and disk file with the same code.
  A restriction with this is that seeking and reading must be done with the function
pointers inside "LX_module", "lx_fseek()" and "lx_fread()". Reading of the file is done in
"modlx.c". A second restriction is when dlls are loaded which must be real files and accessibly
through the libpath (set in driver prog).

Simple process
Next is a structure "t_processlx" initialized with the function "processlx_create()". 
This keeps info about which "LX_module" it is connected to. It also has the head node 
for a memory list to keep track of which virtual memory blocks has been taken by a process.

Now, the code, data and other objects are loaded from the exe file with
"load_dll_code_obj_lx()". Which is also used to read the objects(code, data and resource) 
from a dll file.

The exe is registered in the module list. 

Next step is processing of fixups in "loadobjlx.c". This part is the key which "drags" in 
all dependent dlls and recursively loads and applies their fixups.


------------------------------------------------------------------------------
Building

To build, it needs GNU C++ compiler and GNU make. There are some assembler stuff in "execlx.c"
in GAS format. (Some initial work with porting them to Open Watcom, there is now.)

-----------------------------------------------------------------------------
Example LX programs:

This version does not link in OWs runtime library, only the parts we specify. So
it simplifies debugging. The MSG.DLL in this case should be a forwarder (by name) to
an ELF shared library. If lxloader does not find a dll with a module name and the entry is
exported by name it looks in native_libpath after an .so file with this form: 
  lib<module name>.so
All filename is converted to lower case. The ELF .so is an ordinary shared library with
the function "DosPutMessage" (case sensitive). 

BUGS
There are some bugs which happen if "DosPutMessage"
accesses static strings inside the ELF .so file. I don't know yet how to handle that. 
For now I just avoid using them. Suggestions are welcome ;)
Ops! There is some problem with the generated exe (OW 1.6). The stack/data object has a wrong index.
FIXED. It had incorrect pragma directive. Should work now.

wdump mini33.exe

...
object # for initial EIP                          = 00000001H
initial EIP                                       = 00000013H
object # for initial ESP                          = 00000003H
initial ESP                                       = 00008000H
...
# of objects in module                            = 00000002H
...
-------------------------------
The number of objects is two and the "object # for initial ESP" points at 3! Very wrong. 
Change it with a hex editor to 2. That is the second object that wdump shows.
The LX Header starts at 0x80 (dec. 128) 
The fields up to "object # for initial ESP" is:
    byte order             (1 byte)
    word order              1
    linear EXE format level 4
    cpu type                2
    os type                 2
    module version          4
    module flags            4
    # module pages             4
    object # for initial EIP   4
    initial EIP                4
    object # for initial ESP   pos: 30 + 128 = 158 (157 zero based)
      the four bytes looks like this: 00 00 00 03
      change the 3 to an 2
    
    
-----------------------------

void puts(char *s); 

#pragma data_seg("MYDATA", "STACK") 
#pragma code_seg("DGROUP", "STACK") 



#define INCL_DOSMISC
 #include <os2.h> 

APIRET APIENTRY DosPutMessage(HFILE hfile, ULONG cbMsg, PCHAR pBuf);
/*int _System DosPutMessage(unsigned int hfile, unsigned int cbMsg, char * pBuf);*/

void _System startup(void) { 
    /*puts(msg); */
	char  msg[] = "I'm really small!\n"; 
	DosPutMessage(1, sizeof(msg), &msg);
} 

/*
APIRET APIENTRY DosPutMessage(HFILE hfile, ULONG cbMsg, PCHAR pBuf); 
 ordinal: MSG.5 
unsigned int DosPutMessage(unsigned int hfile, unsigned int cbMsg, char * pBuf)
*/

/*
This is built with the following commands (old form with stars, non working): 

**** wcc386 -s -g=DGROUP mini3.c  ****
**** wlink sys os2v2 name .exe f mini3 imp puts_ LIBCM.362 op start=startup,st=32k,nod ***
****  -g=DGROUP

wcc386 -bt=os2v2 -i/mnt/c/Projekt/open_watcom_src_1.6/rel2/h/os2 -s -g=DGROUP mini33.c
wlink sys os2v2 name mini33.exe f mini33 imp DosPutMessage MSG.5 op start=startup,st=32k,nod 
*/

---------------------------
