
                    osFree Boot sequence (Draft I)

     Note:  This  document  is  in  development  stage. You can send fixes and
changes to it.
     Note:  Multiboot specification is supported in limited range. We consider
not all features are required. Video mode setting is not a loader problem. The
loader has to load and nothing more ;-)
     Note:  This  document  uses  parts  of  Multiboot  Specification document
version 0.6.93

Introduction

     The  osFree  boot  sequence  does not use a classic solution like GRUB or
LILO  usage.  GRUB is a good program, but has some disadvantages. Main of them
is,  the loader must know about the file system (FS) structure. This means, to
support  a  new  file  system,  you need (as user) to update GRUB with a newer
version to support the new FS (if any support is presented). As developer, you
need to add a file system driver to the kernel and to the boot loader. In most
cases  this  means  different  architecture, programming style and development
environment.  We  don't  want to update the whole system to support only small
advantages  (in  comparison  with  whole  OS).  We  don't want to reinstall or
upgrade  most  system  components any time for "mouse pointer with shadow". We
want  to  have  total cost ownership on minimal level. As result we reused the
installable  file system (IFS) approach from OS/2. We don't describe internals
of  MicroFSD  and MiniFSD here because this is the task of an IFS document but
not Kernel Loader internals and interfaces.

Brief overview of osFree boot sequence

     When  the  computer  is  turned  on  or  reseted, the first program to be
executed  is  the  BIOS.  There  are different BIOSes with different execution
sequence.  We  only  have  to  know  one  thing:  The BIOS (Standard, BOOTrom,
PXE-BIOS or something else) loads the boot sector (under term 'boot sector' we
understand  not  only  actual  harddisk boot sector or PXE boot image, but any
first code which is loaded by the hardware and executed) and passes control to
it.

     And  here  our boot sequence starts. We name all code executed before our
boot  sector  as  BlackBox.  We  don't know how it works. We only know we have
control  passed  to our code. Our boot sector is storage depended 16-bit code.
The  boot sector loads a first stage loader named MicroFSD, MiniFSD and Kernel
Loader.  MicroFSD  is  Micro  File  System Driver. MiniFSD is Mini File System
Driver.  Kernel  Loader is code which loads and executes the osFree kernel (or
any multiboot compatible kernel, if user prefers).

     The  code in the boot sector fills information structures and passes them
to  the  Kernel Loader. Those Information structures contain information about
the current memory allocation and MicroFSD entry points.

     The   Kernel   Loader   is   16-bit/32-bit   mixed   code.   It   loads a
multiboot-compatible kernel image, reallocates it and MiniFSD in memory, links
entry  points,  switches  the  CPU to protected mode and passes control to the
Kernel. Kernel and MiniFSD are not 16-bit code but 32-bit.

MicroFSD/KernelLoader interface

     The  MicroFSD/KernelLoader  interface  is  the  same  as  for OS/2. After
MicroFSD has loaded all required code (MiniFSD image, OS3LDR image), it passes
control  to  KernelLoader  (OS3LDR).  The CPU must be in real mode and the CPU
registers must be filled like in the following table.
ÿ
     When  initially  transferring  control  to OS3LDR from a "black box", the
following interface is defined: ÿ


Register        Contains                      Description

DH              Boot mode flags

bit 0 (NOVOLIO) on indicates that the mini-FSD does not use MFSH DOVOLIO.
bit 1 (RIPL) on indicates that boot volume is not local (RIPL boot)
bit 2 (MINIFSD) on indicates that a mini-FSD ispresent.
bit 3 (RESERVED)
bit 4 (MICROFSD) on indicates that a micro-FSD is present.
bits 5-7 are reserved and MUST be zero.

DL  Boot disk drive number This parameter is ignored if either the NOVOLIO or
                                                        MINIFSD bits are zero.

DS:SI pointer to the BOOT Media's BPB This parameter is ignored if either the
                                             NOVOLIO or MINIFSD bits are zero.

ES:DI                                        pointer to a filetable structure

struct FileTable {
   /* # of entries in this table */
   unsigned short ft cfiles;
   /* paragraph # where OS2LDR is loaded */
   unsigned short ft ldrseg;
   /* length of OS2LDR in bytes */
   unsigned long  ft ldrlen;
   /* paragraph # where microFSD is loaded   */
   unsigned short ft museg;
   /* length of microFSD in bytes */
   unsigned long  ft mulen;
   /* paragraph # where miniFSD is loaded */
   unsigned short ft mfsseg;
   /* length of miniFSD in bytes */
   unsigned long  ft mfslen;
   /* paragraph # where RIPL data is loaded */
   unsigned short ft ripseg;
   /* length of RIPL data in bytes. */
   unsigned long  ft riplen;

   /* The next four elements are pointers to
      microFSD entry points     */
   unsigned short(far *ft muOpen)(char far *pName,
                  unsigned long far *pulFileSize);
   unsigned long (far *ft muRead)(long loffseek,
             char far *pBuf, unsigned long cbBuf);
   unsigned long (far *ft muClose)(void);
   unsigned long (far *ft muTerminate)(void);
}




The microFSD entry points interface is defined as follows:


mu_Open

     is  passed  a  far pointer to the name of the file to be opened and a far
pointer  to  a  ULONG  to  return  the  file size. The re-turned value (in AX)
indicates success(0) or failure (non-0).

mu_Read

     is  passed a seek offset, a far pointer to a data buffer, and the size of
the  data  buffer.  The returned value(in DX:AX) indicates the number of bytes
actually read.

mu_Close

     has  no  parameters  and  expects  no return value. It is a signal to the
micro-FSD that the loader is done reading the current file.

mu_Terminate

     has  no  parameters  and  expects  no return value. It is a signal to the
micro-FSD that the loader has finished reading the boot drive.

     The  loader  will  call the micro-FSD in a Open-Read-Read-....-Read-Close
sequence  for  each  file  read  in  from  the boot drive. After all files are
loaded, mu Terminate must be called.

KernelLoader/Kernel interface

     The  KernelLoader/Kernel  interface  is not OS/2 compatible but multiboot
compatible.  This  means  you  can load different kernels, for example a Linux
kernel.

There are three main aspects of a Kernel loader/Kernel image interface:

1. The format of an Kernel image as seen by a Kernel loader.
2. The state of a machine when a Kernel loader starts an operating system.
3. The format of information passed by a Kernel loader to an operating system.

Kernel image format

     A  Kernel image may be an ordinary 32-bit executable file in the standard
format for that particular operating system, except that it may be linked at a
non-default  load  address  to  avoid loading on top of the PC's I/O region or
other  reserved  areas,  and  of  course it should not use shared libraries or
other fancy features.

     A  Kernel  image  must  contain  an  additional  header, called Multiboot
header,  besides  the  headers  of  the  format  used by the Kernel image. The
Multiboot  header  must be contained completely within the first 8192 bytes of
the Kernel image, and must be longword (32-bit) aligned. In general, it should
come  as  early  as  possible and may be embedded in the beginning of the text
segment after the real executable header.


The layout of the Multiboot header

The layout of the Multiboot header must be as follows:


Offset  Type    Field Name      Note
0       u32     magic   required
4       u32     flags   required
8       u32     checksum        required
12      u32     header addr     if flags[16] is set
16      u32     load addr       if flags[16] is set
20      u32     load end addr   if flags[16] is set
24      u32     bss end addr    if flags[16] is set
28      u32     entry addr      if flags[16] is set
32      u32     mode type       must be ignored
36      u32     width   must be ignored
40      u32     height  must be ignored
44      u32     depth   must be ignored


     The  fields magic, flags and checksum are defined in Header magic fields,
the  fields header addr, load addr, load end addr, bss end addr and entry addr
are  defined in Header address fields, and the fields mode type, width, height
and depth are defind in Header graphics fields.

The magic fields of Multiboot header
magic
     The field magic is the magic number identifying the header, which must be
the hexadecimal value 0x1BADB002.

flags
     The  field  flags  specifies  features  that the Kernel image requests or
requires  of  an Kernel loader. Bits 0-15 indicate requirements; if the kernel
loader  sees  any  of  these bits set but doesn't understand the flag or can't
fulfill the requirements it indicates for some reason, it must notify the user
and  fail  to load the Kernel image. Bits 16-31 indicate optional features; if
any  bits in this range are set but the kernel loader doesn't understand them,
it   may   simply   ignore   them   and   proceed  as  usual.  Naturally,  all
as-yet-undefined  bits in the flags word must be set to zero in Kernel images.
This  way,  the  flags  fields  serves  for  version control as well as simple
feature selection.

     If  bit  0  in  the flags word is set, then all boot modules loaded along
with  the  operating  system  must  be  aligned on page (4KB) boundaries. Some
operating  systems  expect to be able to map the pages containing boot modules
directly  into  a  paged  address space during startup, and thus need the boot
modules to be page-aligned.

     If  bit  1 in the flags word is set, then information on available memory
via at least the mem * fields of the Multiboot information structure (see Boot
information  format)  must  be  included.  If  the kernel loader is capable of
passing  a  memory  map  (the  mmap  *  fields) and one exists, then it may be
included as well.

     The bit 2 in the flags word must be ignored by Kernel loader.

     If  bit  16  in the flags word is set, then the fields at offsets 8-24 in
the  Multiboot header are valid, and the kernel loader should use them instead
of  the  fields in the actual executable header to calculate where to load the
Kernel  image.  This  information  does  not need to be provided if the kernel
image  is  in  ELF  format,  but  it must be provided if the image is in a.out
format  or in some other format. Compliant kernel loaders must be able to load
images  that  either are in ELF format or contain the load address information
embedded  in  the  Multiboot  header;  they  may  also  directly support other
executable  formats,  such  as particular a.out variants, but are not required
to.

checksum
     The  field  checksum  is a 32-bit unsigned value which, when added to the
other  magic fields (i.e. magic and flags), must have a 32-bit unsigned sum of
zero.

The address fields of Multiboot header
     All  of the address fields enabled by flag bit 16 are physical addresses.
The meaning of each is as follows:

header addr
     Contains  the  address  corresponding  to  the beginning of the Multiboot
header -- the physical memory location at which the magic value is supposed to
be  loaded.  This field serves to synchronize the mapping between Kernel image
offsets and physical memory addresses.

load addr
     Contains  the  physical address of the beginning of the text segment. The
offset  in  the  Kernel image file at which to start loading is defined by the
offset  at  which  the header was found, minus (header addr - load addr). load
addr must be less than or equal to header addr.

load end addr
     Contains  the  physical address of the end of the data segment. (load end
addr  - load addr) specifies how much data to load. This implies that the text
and  data  segments  must be consecutive in the Kernel image; this is true for
existing  a.out  executable  formats. If this field is zero, the kernel loader
assumes that the text and data segments occupy the whole Kernel image file.ÿ

bss end addr
     Contains  the  physical address of the end of the bss segment. The kernel
loader  initializes  this area to zero, and reserves the memory it occupies to
avoid  placing boot modules and other data relevant to the operating system in
that  area.  If  this  field  is  zero,  the kernel loader assumes that no bss
segment is present.

entry addr
     The  physical  address to which the kernel loader should jump in order to
start running the operating system.

Machine state
     When  the  kernel loader invokes the 32-bit operating system, the machine
must have the following state:



EAX

     Must  contain  the  magic  value  0x2BADB002;  the presence of this value
indicates  to the operating system that it was loaded by a Multiboot-compliant
kernel  loader  (e.g.  as  opposed  to  another type of kernel loader that the
operating system can also be loaded from).

EBX
     Must  contain  the  32-bit  physical address of the Multiboot information
structure provided by the kernel loader (see Boot information format).

CS
     Must  be  a  32-bit  read/execute  code segment with an offset of 0 and a
limit of 0xFFFFFFFF. The exact value is undefined.

DS/ES/FS/GS/SS
     Must  be  32-bit read/write data segments with an offset of 0 and a limit
of 0xFFFFFFFF. The exact values are all undefined.

A20 gate
     Must be enabled.

CR0     Bit 31 (PG)
     must be cleared. Bit 0 (PE) must be set. Other bits are all undefined.

EFLAGS  Bit 17 (VM)
     must  be  cleared.  Bit  9  (IF)  must  be  cleared.  Other  bits are all
undefined.


     All other processor registers and flag bits are undefined. This includes,
in particular:


ESP
     The Kernel image must create its own stack as soon as it needs one.

GDTR
     Even though the segment registers are set up as described above, the GDTR
may  be invalid, so the Kernel image must not load any segment registers (even
just reloading the same values!) until it sets up its own GDT.

IDTR
     The  Kernel image must leave interrupts disabled until it sets up its own
IDT.


     However,  besides  this  the  machine  state should be left by the kernel
loader  in  normal  working order, i.e. as initialized by the BIOS (or DOS, if
that's what the kernel loader runs from). In other words, the operating system
should  be  able to make BIOS calls and such after being loaded, as long as it
does  not overwrite the BIOS data structures before doing so. Also, the kernel
loader  must leave the PIC programmed with the normal BIOS/DOS values, even if
it changed them during the switch to 32-bit mode.

Boot information format
     Upon  entry  to  the  operating  system,  the  EBX  register contains the
physical  address of a Multiboot information data structure, through which the
kernel  loader  communicates  vital  information  to the operating system. The
operating  system  can use or ignore any parts of the structure as it chooses;
all information passed by the kernel loader is advisory only.

     The  Multiboot information structure and its related substructures may be
placed  anywhere  in  memory  by  the kernel loader (with the exception of the
memory  reserved  for  the  kernel  and  boot  modules,  of course). It is the
operating system's responsibility to avoid overwriting this memory until it is
done using it.

The format of the Multiboot information structure (as defined so far) follows:
          +-------------------+
  0       | flags             |    (required)
          +-------------------+
  4       | mem lower         |    (present if flags[0] is set)
  8       | mem upper         |    (present if flags[0] is set)
          +-------------------+
  12      | boot device       |    (present if flags[1] is set)
          +-------------------+
  16      | cmdline           |    (present if flags[2] is set)
          +-------------------+
  20      | mods count        |    (present if flags[3] is set)
  24      | mods addr         |    (present if flags[3] is set)
          +-------------------+
  28 - 40 | syms              |    (present if flags[4] or
          |                   |                flags[5] is set)
          +-------------------+
  44      | mmap length       |    (present if flags[6] is set)
  48      | mmap addr         |    (present if flags[6] is set)
          +-------------------+
  52      | drives length     |    (present if flags[7] is set)
  56      | drives addr       |    (present if flags[7] is set)
          +-------------------+
  60      | config table      |    (present if flags[8] is set)
          +-------------------+
  64      | boot loader name  |    (present if flags[9] is set)
          +-------------------+
  68      | apm table         |    (present if flags[10] is set)
          +-------------------+
  72      | vbe control info  |    (must be filled by)
  76      | vbe mode info     |
  80      | vbe mode          |
  82      | vbe interface seg |
  84      | vbe interface off |
  86      | vbe interface len |
          +-------------------+


     The first longword indicates the presence and validity of other fields in
the  Multiboot information structure. All as-yet-undefined bits must be set to
zero  by  the  kernel loader. Any set bits which the operating system does not
understand  should  be  ignored.  Thus,  the  flags  field also functions as a
version indicator, allowing the Multiboot information structure to be expanded
in the future without breaking anything.

     If  bit  0 in the flags word is set, then the mem * fields are valid. mem
lower   and  mem  upper  indicate  the  amount  of  lower  and  upper  memory,
respectively, in kilobytes. Lower memory starts at address 0, and upper memory
starts  at  address 1 megabyte. The maximum possible value for lower memory is
640 kilobytes. The value returned for upper memory is maximally the address of
the  first upper memory hole minus 1 megabyte. It is not guaranteed to be this
value.

     If  bit  1 in the flags word is set, then the boot device field is valid,
and indicates which BIOS disk device the kernel loader loaded the Kernel image
from.  If  the  Kernel  image was not loaded from a BIOS disk, then this field
must  not  be present (bit 3 must be clear). The operating system may use this
field  as  a hint for determining its own root device, but is not required to.
The boot device field is laid out in four one-byte subfields as follows:

   +-----+-----+-----+-----+
   |drive|part1|part2|part3|
   +-----+-----+-----+-----+
     ÿ
     The  first  byte contains the BIOS drive number as understood by the BIOS
INT 0x13 low-level disk interface: e.g. 0x00 for the first floppy disk or 0x80
for the first hard disk.

     The three remaining bytes specify the boot partition. part1 specifies the
top-level  partition  number, part2 specifies a sub-partition in the top-level
partition,  etc.  Partition  numbers  always start from zero. Unused partition
bytes  must  be  set  to 0xFF. For example, if the disk is partitioned using a
simple  one-level  DOS  partitioning  scheme,  then  part1  contains  the  DOS
partition  number, and part2 and part3 are both 0xFF. As another example, if a
disk  is  partitioned  first  into  DOS  partitions, and then one of those DOS
partitions  is  subdivided  into  several BSD partitions using BSD's disklabel
strategy, then part1 contains the DOS partition number, part2 contains the BSD
sub-partition within that DOS partition, and part3 is 0xFF.

     DOS  extended partitions are indicated as partition numbers starting from
4  and  increasing,  rather  than  as  nested  sub-partitions, even though the
underlying  disk  layout of extended partitions is hierarchical in nature. For
example,  if  the  kernel loader boots from the second extended partition on a
disk  partitioned  in  conventional DOS style, then part1 will be 5, and part2
and part3 will both be 0xFF.

     If  bit  2  of the flags longword is set, the cmdline field is valid, and
contains  the physical address of the command line to be passed to the kernel.
The command line is a normal C-style zero-terminated string.

     If bit 3 of the flags is set, then the mods fields indicate to the kernel
what  boot modules were loaded along with the kernel image, and where they can
be found. mods count contains the number of modules loaded; mods addr contains
the  physical  address  of the first module structure. mods count may be zero,
indicating  no  boot  modules were loaded, even if bit 1 of flags is set. Each
module structure is formatted as follows:

           +-------------+
     0     | mod start   |
     4     | mod end     |
           +-------------+
     8     | string      |
           +-------------+
    12     | reserved(0) |
           +-------------+

     The  first  two  fields  contain  the start and end addresses of the boot
module  itself. The string field provides an arbitrary string to be associated
with  that  particular boot module; it is a zero-terminated ASCII string, just
like  the kernel command line. The string field may be 0 if there is no string
associated with the module. Typically the string might be a command line (e.g.
if  the  operating  system  treats  boot modules as executable programs), or a
pathname (e.g. if the operating system ÿtreats boot modules as files in a file
system),  but  its exact use is specific to the operating system. The reserved
field  must  be  set  to  0  by the kernel loader and ignored by the operating
system.

Caution: Bits 4 & 5 are mutually exclusive.

     If  bit  4  in  the  flags  word is set, then the following fields in the
Multiboot information structure starting at byte 28 are valid:

           +--------------+
    28     | tabsize      |
    32     | strsize      |
    36     | addr         |
    40     | reserved (0) |
           +--------------+

     These  indicate  where the symbol table from an a.out kernel image can be
found.  addr  is the physical address of the size (4-byte unsigned long) of an
array  of  a.out  format  nlist  structures, followed immediately by the array
itself, then the size (4-byte unsigned long) of a set of zero-terminated ASCII
strings  (plus  sizeof(unsigned  long)  in  this case), and finally the set of
strings itself. tabsize is equal to its size parameter (found at the beginning
of  the  symbol section), and strsize is equal to its size parameter (found at
the  beginning  of  the string section) of the following string table to which
the  symbol  table  refers. Note that tabsize may be 0, indicating no symbols,
even if bit 4 in the flags word is set.

     If  bit  5  in  the  flags  word is set, then the following fields in the
Multiboot information structure starting at byte 28 are valid:

           +--------------+
    28     | num          |
    32     | size         |
    36     | addr         |
    40     | shndx        |
           +--------------+
     These  indicate where the section header table from an ELF kernel is, the
size  of each entry, number of entries, and the string table used as the index
of  names.  They  correspond  to  the  shdr  * entries (shdr num, etc.) in the
Executable  and Linkable Format (ELF) specification in the program header. All
sections are loaded, and the physical address fields of the ELF section header
then  refer  to  where  the  sections  are  in  memory  (refer to the i386 ELF
documentation  for details as to how to read the section header(s)). Note that
shdr  num  may be 0, indicating no symbols, even if bit 5 in the flags word is
set.
ÿ
     If  bit 6 in the flags word is set, then the mmap * fields are valid, and
indicate  the  address  and  length of a buffer containing a memory map of the
machine provided by the BIOS. mmap addr is the address, and mmap length is the
total  size of the buffer. The buffer consists of one or more of the following
size/structure pairs (size is really used for skipping to the next pair):

           +----------------+
    -4     | size           |
           +----------------+
     0     | base addr low  |
     4     | base addr high |
     8     | length low     |
    12     | length high    |
    16     | type           |
           +----------------+

     where size is the size of the associated structure in bytes, which can be
greater  than  the  minimum of 20 bytes. base addr low is the lower 32 bits of
the  starting address, and base addr high is the upper 32 bits, for a total of
a  64-bit starting address. length low is the lower 32 bits of the size of the
memory region in bytes, and length high is the upper 32 bits, for a total of a
64-bit length. type is the variety of address range represented, where a value
of  1  indicates  available  RAM,  and  all other values currently indicated a
reserved area.

     The  map  provided  is guaranteed to list all standard RAM that should be
available for normal use.

     If  bit  7  in  the flags is set, then the drives * fields are valid, and
indicate  the address of the physical address of the first drive structure and
the size of drive structures. drives addr is the address, and drives length is
the  total size of drive structures. Note that drives length may be zero. Each
drive structure is formated as follows:

             +-------------------+
     0       | size              |
             +-------------------+
     4       | drive number      |
             +-------------------+
     5       | drive mode        |
             +-------------------+
     6       | drive cylinders   |
     8       | drive heads       |
     9       | drive sectors     |
             +-------------------+
     10 - xx | drive ports       |
             +-------------------+

     The  size  field  specifies  the size of this structure. The size varies,
depending on the number of ports. Note that the size may not be equal to (10 +
2 * the number of ports), because of an alignment.

     The  drive  number  field  contains the BIOS drive number. The drive mode
field  represents  the  access  mode used by the kernel loader. Currently, the
following modes are defined:


0       CHS mode (traditional cylinder/head/sector addressing mode)
1       LBA mode (Logical Block Addressing mode)


     The  three  fields,  drive  cylinders,  drive  heads  and  drive sectors,
indicate  the  geometry  of  the  drive  detected by the BIOS. drive cylinders
contains  the  number of the cylinders. drive heads contains the number of the
heads. drive sectors contains the number of the sectors per track.

     The  drive  ports  field contains the array of the I/O ports used for the
drive  in the BIOS code. The array consists of zero or more unsigned two-bytes
integers,  and  is  terminated  with zero. Note that the array may contain any
number  of  I/O  ports that are not related to the drive actually (such as DMA
controller's ports).

     If  bit  8  in the flags is set, then the config table field is valid and
indicates  the  address  of  the  ROM  configuration table returned by the GET
CONFIGURATION  BIOS  call.  If the BIOS call fails, then the size of the table
must be zero.

     If  bit  9  in the flags is set, the boot loader name field is valid, and
contains  the  physical  address  of  the  name of a kernel loader booting the
kernel. The name is a normal C-style zero-terminated string.

     If bit 10 in the flags is set, the apm table field is valid, and contains
the physical address of an APM table defined as below:

           +-------------+
     0     | version     |
     2     | cseg        |
     4     | offset      |
     8     | cseg 16     |
    10     | dseg        |
    12     | flags       |
    14     | cseg len    |
    16     | cseg 16 len |
    18     | dseg len    |
           +-------------+

     The fields version, cseg, offset, cseg 16, dseg, flags, cseg len, cseg 16
len,  dseg  len  indicate  the  version number, the protected mode 32-bit code
segment,  the  offset  of  the  entry  point,  the  protected mode 16-bit code
segment,  the protected mode 16-bit data segment, the flags, the length of the
protected  mode  32-bit  code segment, the length of the protected mode 16-bit
code  segment,  and  the  length  of  the  protected mode 16-bit data segment,
respectively.  Only  the  field offset is 4 bytes, and the others are 2 bytes.
See  Advanced  Power  Management  (APM) BIOS Interface Specification, for more
information.

The bit 11 in the flags must be zero.

For Installable File System drivers developers

     Installable  File  System (IFS) drivers are described in the IFS document
(not yet published).

Kernel Loader internals

     The  Kernel  Loader  is raw 16-bit/32-bit binary code (like MS/PC-DOS COM
files, but started not from 100h but from 0h).

       First of all, Kernel Loader stores all information from CPU registers into internal structures
       Depending on this information stores info about memory allocation
       After this it show information on display
       Loads kernel
       Swtiches to protected mode
       And executes multiboot compatible Kernel

Nothing more here! Wasn't it easy? ;-)
